# algorithm-in-public
nurrizky journal of defeating the inability to think in algorithms

# M9/W2/D17 - Wed, 17 Sept 25
1. Visualization number 1 → the only way the only path; visualize the number; visualzied the way; visualize in algorithm way; vs in the visual way; increment way vs end look way;

# M9/W2/D16 - Tue, 16 Sept 25

Algorithm Principle

1. Algrithm Agent
    1. looping, → sorting, findnt min, or mfinding max; 
2. each of the agent, see the big process → see if things already in sort; or min, for finding max; or finding min;
3. check for if things are bigger or smaller, or exist or not exist; zero or not zero; bigger or smaller → visited or not visted; exist or not exist; 
4. agent block
    1. looping finding max; looping finding min base don array
    2. prefix  each of mdinding max, prefix min, prefix sum; prefix count map;
    3. prefix exist , previs not exist
5. everyting is prefix; 
    1. last x, previous, current, → the vocabularity of prefix, the vocabulary context

# M9/W2/D15 - Mon, 15 Sept 25

Algorithm Principle

1. sum and count → same philosophically commulative on thismg ereyruing is an array;a dn evreyrhig emans that ther eis always something to collect or sum or count up;
2. check sum check count → in every sum and count → will check on the coordinate if tthing elss or more or exist and not exist; 
3. filtered save → filter saved things into new array
4. filtered sum → filter thinsg to sum
5. filter count → filter things to

# M9/W2/D14 - Sun, 14 Sept 25

Algorithm Principle

1. Keep or ignore; we keep x case, we are ignore the y case; ignore or keep; 
2. ranking, order, increase decrease, sorting
3. count again, sum again, prefix sum again; calculation again, move it into structure again;
4. everything is an array → every everyting can be virtualized breakdown to array
5. everyuting is an array 

# 9M9/W2/D13 - Sat, 13 Sept 25

Algorithm Principle

1. component
    1. know your operation → you can only do x, you can only do x, you have x 
    2. know your input → array or 2d array
    3. coordinate, gap, and index; 
    4. values
2. think the algorithm shortcut
    1. loop normaly; 
    2. counting
    3. prefix sum, prefix count, prefix max and min; prefix best
3. virtualization
    1. add metrix or dp array
    2. new prefix sum variable, prefix max variable prefix context variablism
    3. queue or stack way of order things
    4. graph way to see things,
    5. recursion based data structure;
4. characteristc
    1. adjejency
    2. substrirng
    3. subsequence
    

# M9/W2/D12 - Fri, 12 Sept 25

Algorithm Principle

1. you just need to loop it normally; so think it as an options in the endn; but thceratin optiosn has sginficant ompact; like possibel if certain things do iing it now it wil impact bigger; 
    1. prefix vs option mentality
2. on greedy way to solve things → I always think in the component of :
    1. thisngs should be easily solve in loop, 
    2. we compare, check sum, visited or existed, for the number of value
    3. extrct value or, extract index, 
    4. consider max or min, of things, then we can use the prefix filter, or prefix sum; 
    5. is this blind order → options, of consicous about order → current now, or which to pick 
3. skip or pick, sum or substact; find the gap between, baseline refernece is i; and we compare with i and i+1 or i-1 p
4. window context → on how min and max show the finding of the best based on the contex long; some of them just think yesterfday, other use the beginning to the end of the current coordinate; 
5. skip pattern, substract pattern → if the case is loose; and wrong, then just disregard; beyodn, melebihi, mengurangi; 
6. array pattern → mostly in greedy
    1. skip or keep pattern
    2. judgement → bigger vs smaller, gap bigger or smaller, visited vs not visited, exist not exist, count bigger vs count smaller vs empty or not,  if less than coordiante vs more than coordinate
        1. bigger or not, smaller or not
        2. exist or ot, not exist or not
        3. zero or not , not zero or not 
        4. visited or not, not visited or not;
        5. n or not, first or not; 
        6. similar or not
        7. in between coordinate or not, not in between coordniate or not; 
        8. exist or not, same or not; 
    3. removing and skip is the same things, we remove we skip, its all the same similar things; 
    4. reset vs continue → pick between these, we continue we add, we rest, then make it empty or null; as part of new fresh on that index; 
7. the build up → stack → hey if the previous in stack bigger → REMOVE, we change reset into the new → what new there; 
8. virtualizaton → extraction, or creation new data strcture, which put and get will have differne rsule depend of the internal data structure logic 

# M9/W2/D11 - Thu, 11 Sept 25

Algorithm Principle

1. No calcualtion, just pure check if beyond border or not → beyond coordinate; beyond exist; 
2. intinya tu cuma cocok2in aja → coordiante cocok2inn. aja. 
3. breakdown → fourier tranform type shit → to break things into smalller pieces
4. combination of prefixSum, minMax game, coordinate playing, and end to end zero to n game, conservative 0-n game;
5. k limit → cheking if the slot still exist or not
6. filter prefix sum → sum based on the case by case only
7. filter process  → process absed on the case of fitlered; 
8. calculated vs check case only → some of the process can be cosnder as calcualtion, some also check by case; 

# M9/W2/D10 -  Wed, 10 Sept 25

Algorithm Principle

1. prefix best pick; prefix max pick, prefix min pick; 
2. j and i looop → slow j and fast incremental i loop;
3. just refere to the coordidate; coordate is your king and your good; 
4. flag pivot changer → there are some where the flag change the behaviour or things
5. operation vs condition → the condition and the operation, the restrcitioon of achieving and defining something 
6. what next ? the iteration of the future → think about the iteration fot he future of tiangs; and see what kind of coordiate they use; or not using at all; just avlue based; 
7. order care vs not order care → thinking about the order or not of the order of that

# M9/W2/D9 - Tue, 9 Sept 25

Algorithm Principle

1. ensure balance between understadnia boutthe index, and understanding about if else; 
2. agent → for every separate loop or process, we call it agent, separate concern what to do; separate where it 
3. index playing → coordinate → see the index and their way they play the index
    1. looping variety → looping blind, looping non blind index i, 
    2. operation based given → minimum operation 
    3. comparison of two index, shall be structurized → where it structured into who own the coordination process; 
4. independent taker vs dependent taker → taking the previous based on the calcualtion or ot; 

# M9/W2/D8 - Mon, 8 Sept 25

Algorithm Principle

1. no obsvious vs obvious solution → instead doing thing in the first thing you have thought about, we do things we 
2. what can you learn from it? counting, the loop from the n - 0;  always think in the if else, if else, if if else else case
3. do you remember the algorithm → always start with a question, and be honest about it → develop automaticyt; for counting
4. binary search → based template of binary search, and use new func for case; 
5. index i and j → to think that most of the time its only i and j; 
6. data struct → exist and not exist; 
7. operations → you have x capabilities, you are allowed to do x; whcch in the end of the ints alway related with the value the index or something, for sure following the guide 
8. tools → coordiniate, index → better name : coordinate more than index, explain a lot about it, and less detail about the value; value vs coordianate; 
9. tools → from left and right → how traversing based on coordinate can be done both left and right;k
10. coordiate related tools → index before, index after, index + 1, index -1, index % 2 == 0, index i compare to index j; index + 10; vs index + 1; baseline index i, then second order index j; 
11. middle starter index 
12. all everything assume, follow the array<integer> list, everything follow the god array; everything is array able; 

# M9/W1/D7 - Sun, 7 Sept 25

Algorithm Principle

1. recurrence relation, is the way we jahit each of the unit, think about all the possibility of the case by case first
2. avoid thinking by the loop; 
3. operations → interface; initial input; judgment value case by case; 

# M9/W1/D6 - Sat, 6 Sept 25

Recall Principle

1. first level → data structure, int n, size, length, value, and index, order
2. second level → prefix sum, summation, cummulation, calculation, index playing 
3. third level → virtualized data structure, list, array, stack, queue, treemap, linkedlist, graph 
4. fourth lvl → know the conditional, what shape or cettain condition; know what conditional you would like to see, what the pattern;  thinking the case first; thinking the impact case;
5. fifth lvl → Recursiveness, the kleep the samething, voer and over thing; the mega pattern of every pattern; 
6. six lvl → interface playing, play with the available interface no matter the lvl of the foundation

# M9/W1/D3 - Wed, 3 Sept 25

Algorithm Principle

1. prefix reference → compare the now and the previous state → how does impact that 
2. array type → colleciton of the best result, a random currently as is number, prefix sum; index reference, naming; 
3. first rank access → the size n; and the anything related number tjat you give;
4. second rank access → the value, and the layer in between that working on that, the layer. 
    1. hilirisasi rank asccess → prefix sum, counting, summation, processing; adding into the data structure; change the structure of the data itself; summation is the king
    2. interface playing → play with the interface, the data structure, the structure help the logic, change the iff and the process; how much + has such magic na ghance;
    3. aciton → ignoring and discarding things is the action, the important signficant action; 
        1. data structure related → sorting action, ignore action, discarding action; 
5. Quantificatin, enumeration → the ability to make things as a number or metrics 
6. capture mentality → capturing, capture value, capture and extract from current; 

# M9/W1/D1 - Tue, 2 Sept 25

**Algorithm Principle**

1. queue and comparsion of the biggest → on how we use the past as comparison of the biggest in the current, and take it as the reference. the reference process of that
2. ifs → always think the ifs more instead of the loop; 

# M9/W1/D1 - Mon, 1 Sept 25

**Algorithm Principle**

1. perform this folliowing → perform this folliwung operation
2. you are given x array, length n arary; with k number and m number and n number
3. current vs previous → before and after. understaind the past and its effect in the future 

# M8/W3/D28 - Thu, 28 Aug 25

**String Principle**

1. string → substring, character unit
2. tools → counting values, optionality, minimum maxmium of hte ocunt or gap gounc; 

**Algorithm Principle**

1. array is good, array is x, array is something → subarray, sub array, sub array  → non negative array
2. mininum → mininum way to make it good
3. gap in between value of array → gap in array, gap in the way of array
4. see the case → case by case, see the case continuous of option blind based; c
5. if else combination → exist not exist and index ia early or late; or value is between the ptipos or not;
6. pohon if else → matters to thinkl fia realdy count or not; 
7. right decision, right guess → or list of options, minimizlied right guess, but automaticity is matter most in the process

# M8/W3/D6 - Wed, 27 Aug 25

**Algorithm Principle**

1. Order blind → order matter, order not matter → order not works
2. the use of stck → pattern to add the stack each then evaluate if the stack peek is bigger than tht current taking nums; this will remove;l till its smaller; thena dd the number to the stack; 
3. pattern elft and right → that pattern evaluate thigns from lefft then we hae separate loop foranother; 
4. separate loop → means separate agent; take a responsibility of bigger thigns

# M8/W3/D6 - Tue, 26 Aug 25

**Taking Note If else** 

1. bigger smaller →  one side is bgger one side is smaller, tools → max min; inequality; 
2. tools → timpa, sum, or increment; 

**Algorithm Principle**

1. counting →  use counting with the array as the counting for for character
2. count and next → the use of count, and the use of the recycle of that, the nature of recycling data; how the data, the number bring history, and sequentialism
3. interface → always back to the interface, what itercae are you using; what the stuff means to you; skill to use the available interface
4. subsequence → subarray, subtring
5. how many path → find k path, bsed on k, find minimum way, find maximum way;
6. count → count number, count xx, 

# M8/W3/D25, Mon, 25 Aug 25

**Brain Retrieval**

1. maximum x based on x path, maxiumum k result, maximum xxx for k bags, minimum subsequence, max result of substing, max result of subnumber, 
2. non overlapping sub array, subsequence, substring, subprocess, sub→ sub in everything
3. subarray equal to the target → target

# M8/W3/D24 - Sun, 24 Aug 25

**Algorithm Principle**

1. loop → the consistency is that to find the loop from left right or middle with binary search
2. relation → then to think about the relation between the unit proces, that the process we only have
3. then the relation means → are you going to save it, are you picking the best, are you sum all of  it, are you ignore or take, are you compare, what to compare what case and what baseline

M8/W3/D23 - Sat, 23 Aug 2025

**Algorithm Principle**

1. bfs → using queue as always, and the use of filling things up; as always; 
2. knowina gain the if boundaries, the ebfore after or that; else other than then what to do? 
3. most of the time the if is always either 2-3 shape of like
4. frequency and frequency table, as. holy grail of map case;
5. looping with from j based on i → as the find simpliciaiton find of combinatoric; 
6. in graph, visited not visited case matter most; 
7. in calculation, less or more, something less or msomething more atters most; in the future
8. for binary tree → always into if null as leaves and if the thigns exist; or counted exist; value → value wize possible but not sure;

# M8/W3/D22 - Fri, 22 Aug 2025

**Algorithm Principle**

1. alway ask → how the relation between each of that; what are we looking here? 
    1. are we looking for 

# M8/W3/D21 - Thu, 21 Aug 25

**Algorithm Principle**

1. inser tor ipdat with filter; is not as it is, you want to put it there there is sstymte mechnaism onh how we insert things out
2. programming is about → managing interface, there are some interface no need to go into deper of each unit, only means that you can use the card available; once you are optimal in the card you have, you want to up the level by going into the unit; 
3. use the available, and ability to retain and think about the interface
    1. managing available interface
4. eureka moment → understading about dp, greedy, and bruteforce, this is the moemnt → at least you find a deep connection of all of that
5. sort it out, count it put, know the filter mechanism → the smaller or bigger

# M8/W3/D19 - Tue, 19 Aug 25

**Algorithm Principle**

1. using map but the map 26 by the char array, comparison for the 

# M8/W3/D18 - Mon, 18 Aug 25

**Algorithm Principle**

1. two pointer → in any situaiton and any structure, and early break mechanism
2. early break → mechanism for early break
3. continuous move pointer → nature of array, pointer of the pointing mechanism

# M8/W2/D13 - Thu, 14 Aug 25

**Algorithm Principle**

1. find anagram 
    1. find k length ubstring
    2. find two non overlapiing subarrays
2. minimum operation
    1. maxium count 
    2. minimum operation make subarray equal
3. longest substring 
    1. shortest smalest beautul string 
4. count number of substring 
    1. coutn number
    2. count prime 
    3. count substring 
5. minmum size subarray
    1. 

# M8/W2/D13 - Wed, 13 Aug 25

**Algorithm Principle**

1. greedy → sorting all the way it works, queue, give or take, max or min; ignore or take, or data structure dictate how things works
2. greedy → do the maximum impact first, the biggest impact first, then the residu use other operation first;
3. two pointer → sincce you need two things to be compare of, or to be process of intetionally; if you just need one piutbe rofduc then tsi good enough; or usually you wan to compare with the past; to reserved pointer; 
4. duality → duality of everhting, if elese there is a case, then ther is nother case of the verseal, reversal exist; ebcause it that how the worldwors;; 
5. allocation process → allocating the process
6. scan fix rule → for while, the fix is the while; if beyond theshold; or its over something then it will play the role and the woye; 

# M8/W2/D12 -  Tue, 12 Aug 25

**Algorithm Principle**

1. you always have tools → index, value, max min, accumulation, prefix sum, give or take, frqeuency counter, level up
2. you alwys hav tools → priority queue, stack, array int map, order effect, 
3. you always have tools → graph map, adj list, queue, stack, recursion
4. think about the naive solution → as base understanding that thign can happend 
5. another day another example how data structure → dictate how thigns flow → 
6. you always have a tools -. order incrasing or decreasing, order, sorted, increase, and decrease
7. another day another monotonic stack, monotonic queue, the same increase or inprove w;

# M8/W2/D11 - Mon, 11 Aug 25

**Algorithm Principle**

1. partition or chunk, aim for bigger into subproblem, sub component, sub unit
2. ignore or take, give or take, take or ignore, for each fo the steps, you want to think if you want to give or take or ignore the thing for the newest or the best; max and min, is the example of ignore or take mentality; 
3. bigger smaller, ignore or take

# M8/W1/D9 - Sat, 9 Aug 25

Algorithm Principle

1. think in the unit size matters, its find to think in flow and case; but then we need to think for each of the unit we evaluate and execute; this is matters, the process. 
2. three is always yuit, think in unit of each of ti; one by one 
3. sum for each of sum total; fore ach of the stateg; youu can sum , you can count, you can pick; you can add, you can remove, you can update; what you ave is unit; and you can do uanythign witht he unit
4. you are using sum, you are using save explore flow by index, you are uisng prefix sum; you are using gap analysis; gap calcualteion; you are susing max math based onf each of the step 
5. for each of the step; we choose prefi sm;
6. for each of th setpe; we pick the best;
7. for each of the step we pick the correct one; and for leveling yp comparingsion; 
8. for each step; we pick and eliminate others; 
9. for each if less than the anchor of the thigns i wnat; then skip; but if skip[’ then eht nex wtithill be different; 

# M8/W1/D8 - Fri, 8 Aug 2025

**Algorithm Principle**

1. there are several path to do when you have no idea to do, several pattenr exist
    1. intervanl, array, string, grid
    2. knowing the summatio, interval, pick k, sum till k

# M8/W1/D7 - Thu, 7 Aug 2025

**Algorithm Principle**

1. using array sort as always → think about the possibility of the sorting the value;
2. on fly sorting → priority queue, which one the ebst; the impact on how the now impact the future; → recurrence relation
3. summation from the best value; and compare get the max on the fly for each of it;

**Greedy Principle**


# M8/W1/D5 - Tue, 5 Aug 2025

**Algorithm Principle**

1. sorting order and candidacy → on how sort order means that value can be skipped → and we play a lot with the binarys earch two pointer  left and right for creat ehte most effective way to creat ecomparison between two index; index play; with 
2. knowing the loops that going to be used → also lvl 2 thinking → the combination with loop and if else 
3. rolling max out → for each of the role you will find a max, or min or whatveter it si as compare or ladder of comparison

# M8/W1/D4 - Mon, 4 Aug 2025

**Algorithm Principle**

1. candidate → for every each of array things, we can consider as candidate; 

# M8/W0/D2 - Sat, 2 Aug 2025

**Knowledge Base** 

1. LOOP AGENT
    1. for loop; left right;
    2. double loop; left right;
    3. while loop; 
    4. two pointer left and right
    5. two pointer slow and fast pointer;
    6. frolop and while loop case loop; 
2. SEQUENTIAL AGENT
3. DATA STRUCTURE AGENT
4. IF ELSE AGENT
    1. max min agenet; you can get the most of info from max and min of the process
    2. agent 

**Algorithm Principle**

1. recursion is agentic, data structure is agentic → they will learn directly; they will adjust decision based on case; they will “automaticallly” do things based on the condition; they dont see thigns as only one; 
    1. agent position  → agent index
    2. agent value
    3. agent data structure 
2. agent → agentic → data structure is agentic → get set put is different depend on the data structure
3. if else definitely agentic → knowing what case and what its going to impact to
4. agentic compare case 
    1. if x exist or not
    2. x is bigger or smaller or not; and x is zero or n ; in between; 
    3. x count is bigge ror esmaller or equal; 
5. so basicallyt there is two → throw the data into random agetic aintelligence → datas structure; or logic if else; 
    1. and ability to manipulate and play with array ish data → index, position, order, bigger smaller; magnitute

# M8/W0/D1 - Fri, 1 Aug 2025

**Algorithm Principle**

1. referential reference → every each loop; we update the referece; each of the loop will loop at the best → lastOccurance → position or index → ebcome matter here; 

# M7/W5/D31 - Thu, 31 July 25

Algorithtm Principle 2

1. position, → see thing on position, what position, what index
2. order and position→ knowig the order, does order matters? order matters? order means something or not? → posisiton, the index? how is it ? ‘
3. comparison of the index, → is in the range or not? is in the way or not? 

Algorithm Principle

1. tools → take index, take position, take value 
2. tools → get the max or get the min; less or bigger 
3. tools → get the n, the the each of the number;
4. tools → prefix sum suffix sum; array sum; each of array state sym; 
5. tools → posititon saving, when position has determental capability more than the frequency; 
6. frequency → 

# M7/W5/D30 - Wed, 30 July 25

Algorithm Principle

1. Knowing the if else, knowing index position matter most
2. prefix and suffix related algorithm → on how the process of current from the past really does impact in big scale. Previous saving, previous counting matters, previous calculation matters
3. we are considerting → considering all options, all substring → meaning to say that you are generateing the whole possible answer; and check if the answer is more than 
4. you can extract the min and the plus and you learn something from them, the min and max is the inisght you have from the array you talk about; 
5. everyting is an array → array of everything

# M7/W5/D29 - Tue, 29 July 25

Array Principle

1. see everything as an array; as a stream of array number streaming to you; list of array
2. that you can loop and find a pattern in between, and you can check if things bigger or smaller or exist or not → can be reset to 0, or can continue
3. reset and point of check → pattern where thigns can be reseted if its bigger smaller or best or what or exist; so that in become the rerefence point for checking, basially for each of the poisiton; you want to compare by the best currently you surround, if you keep referncing to joja based, then it sjust big, but you want to follow the comparison of the currently the best and show how it works well in the process
4. poisiton

# M7/W5/D28 - Mon, 28 July 25

Algorithm Principle

1. position, order, value, index, value index, count, sum
2. compare, less then, equal less, less equal, more equal, equal, exist, not exist, consist, is, are, in grup, not in group
3. set, change, add, substract, minus, plus, subtitute, reset
4. value based → distance, gap, change
5. loop for each, loop 2d for compare sporadict, loop from the start
    1. loop for each, loop one shot, loop next by compare previous
6. think in array ism, everything is array; it has poisiton, order, magnitute compare
7. recursion thinking, things is unit between unit of unit, for each can be each in between
8. basic extract
    1. for each i - n;
    2. int size
    3. value size;

# M7/W4/D26 - Sat, 26 July 25

Algorithm Principle

1. compare, bigger, smaller, exist, count bigger, count smaller, position lower, position higher. maximum, minimum, exist, consist, not in group, in group
2. we believe in array; that algorithm scale because of array-ism. we believe that array is great technology, is the holy grail of pattern ism, holygrail of system pattern
3. distance, gap, different → index, position → value → metrics/process val;
4. direction → left ⇒ right or right ⇒ left 
5. think in array ism → that stuff prob have some pattern in similar as a unit, and order and position does actually helps→ have significant impact in the way we proces tings

# M7/W4/D25 - Fri, 25 July 25

Algorithm Principle

1. Its crazy how algorithm can say things can be solve by an array way; like you know how pattern means you can find the same thing over and over; and i think tis differne with real world where there is a lot of unstructure thigns that led with no noice at all 
2. sequential → time by time, unit by unit, position by position ⇒ each according to the nature, and we find pattern in between;

# M7/W4/D23 - Thu, 24 July 25

Algorithm Principle

1. knowing the index, knowing the position; position matters most; order matter most; 
2. each of position means somehting, we can extract information, we can extract a
3. position and order; and how the next position, does impacted by the previous order or not; this one matter ot understand; 
4. position aware, position aware, position aware; value aware → map and position; how position is enough instead of need of 
5. find the max the best, the lowest the min; find always the best; → no care about position; but then it will result other stuff; 
6. position aware, position aware, order aware, index aware, value aware; sequentialism aware
7. all things run on array and posisiton; we dont ned to map all things; turns out sequentalism aware; the nature is → sequentialism. the nature is → 
8. unit aware, unit ware, unitw ware; tturns out ou dont. eed map the whole thigns, you jsut need sequential array; 

# M7/W4/D23 - Wed, 23 July 25

Algorithm Principle

1. book keeping is the way you go, count things, save increment things. Its really important things to have; count and the count will use as next count of diiffernet domain
2. there is different between sort in greedy and sort as a preprocess → the diffetn come with the decision making that impact the future
3. greedy → pick now and never look back
4. x is complete, good, great → whatever the definiton of the dfiiton of good or bad in algorithm 
5. unerstand what opoeration, what limit and what the boundaries, what step can be use, what problem and what issue can be achieved
6. the existtance of things → use map to check the xistrance of things; use == if the same or not; if else need to be understanded → from the perspective
7. knowing the distinct process what exist in that block of if else; the matter most of the process; 

# M7/W4/D21 - Mon, 21 July 25

Algorithm Principle

1. prefix sum and suffix sum as the methodlogy to solve problem → one of way to solve things
2. write the pseudo code first; then start to code it tarightaflter
3. always see from what you get → the index, the value, hows the pattern, how does the end or wirght;
4. and use all the existing tools available → hashmap, list, stack, queue, 
5. deep insight about the if else, the abilityt to craft the if else , matters most here
6. the problem with code is that, we only have short context window as always; been; and else most of the context reference will need to be save on htings that mostly non intelligence → hasmap; and order and so on; so there is this restricton how the nature workds and the bit and byte works there; 

# M7/W3/D19 - Sat, 19 July 25

Algorithm Principle

1. to think in incrementail. to think greedy or bruteforce; when doing greedy; think one pass; how we can count or what 
2. state based programming, in every process, we are recording the state, and the type; in every type we can do if else, and conditional; we loop for each of type; and how the orders matter most
3. you are bigger than me, you are smaller than me. you are what bigger than me or what
4. either greedy, sorting, or comparison by index; 
5. two pointer compare and reset; and continue if the same; see if things ordered; for array; index++; j++; 

# M7/W3/D18 - Fri, 18 July 25

Algorithm Principle

1. undertand the subsequnce, subarray; 
2. how to unblock your brains → by genrating set options of possible answre; it will take forever, but it worth to value that the abilityt to come up with genuine and origital thought about it are much more determental that just copy paste the thogu of others
3. i still don underatnd hwo come up reading things are not meaning of learning, but still it just not come up with the brain; at least the pattern or what; but even tho thats not even the right things to have 
4. all based on the sequncce → all must find the pattern of the scope itself; a combination for each and which main things need to loop on; 
5. The big loop → conspiracy theory; on how we work on the big looop; in any algorithm there is awlays the big loop; the scope loop; and thei only thing we can do is to blau with inside the lop; you cannot do anyhting; but only to adhere the loop it self → THE BIG LOOP 
6. subseqeunce, subarray, subset → undertanding that certain 
7. first bet always bruteforce, then greedy, and then sliding window;
    1. certain solution using dat structure baesd; → data structured based; 
8. got what i wanted? good? 

# M7/W3/D17 - Thu, 17 July 25

Algorithm Principle

1. instead find the best, find the better; slowly but sure, find the better part of it
2. knowing the operation, what does the operation translate to for algorithm → get remove, set, get process
3. if else check things exist, things smaller or bigger, things equal or not; 

# M7/W3/D16 - Wed, 16 July 25

Algorithm Principle

1. you hav two options; one is solve it fully what expacted; andt the secondnya, you can solve it idrectly; wtihout doing it
    1. example, count generate somehting → usually you think of generating all possubel number
        1. meawhile you can just extract certain info, and no need calcuate the whole entirely;
2. you gotta loop from the beggining, or what if you only be able to do it from the smalles or the start or form be tbiggingin → it feels like your brain want to do things fast; but in algorithm world, you can only do it incementally;  you will find the full path of how things works
3. firs tloop, the basic loop; the first time, the loop is the first; the main loop is the anchor; 
4. find the dictator → find the main dictator. of things; 

# M7/W2/D13 - Sun, 13 July 25

Algorithm Principle

1. I start ot be able to see the how the past influence the future; and i think 
2. dictator → the algoritjm or if else that diactat what hwo tbehave, and bawd onw what; the dictarotr; should be things that is clear;  dictate based oi the start aspit; 

# M7/W2/D7 - Mon 7 July 25

```jsx
stateDiagram-v2
    [*] --> Start
    Start --> Read_T        : read t
    Read_T --> TestLoop

    state TestLoop {
        [*] --> Check_T
        Check_T --> Read_Params : t > 0
        Check_T --> End_All     : t == 0

        Read_Params --> Init_DP  : read n, mod\nf[0][0]=1, ans=0
        Init_DP --> Zero_F       : zero f[i][j] for 1≤i≤n,0≤j≤i

        Zero_F --> OuterLoop

        state OuterLoop {
            [*] --> Check_i
            Check_i --> InnerLoop   : i ≤ n
            Check_i --> Sum_Answer  : i > n

            InnerLoop --> Init_j     : j = 0

            state InnerLoop {
                [*] --> Check_j
                Check_j --> Process_j  : j < i
                Check_j --> End_i      : j == i

                Process_j --> Fetch_now : now = f[i-1][j]
                note right of Fetch_now
                    if now == 0 → skip updates
                    else → two transitions
                end note

                Fetch_now --> Update_inc 
                    : f[i][j+1] += now

                Fetch_now --> Update_mul
                    : f[i][j] += (n−i+1)*(j+1)*now mod

                Update_inc --> Next_j
                Update_mul --> Next_j
                Next_j --> Check_j    : j++

                End_i --> [*]
            }

            End_i --> Inc_i        : i++
            Inc_i --> Check_i
        }

        Sum_Answer --> Compute_ans : ans = ∑ f[n][j]
        Compute_ans --> Print_ans   : print(ans)
        Print_ans --> Dec_T         : t--
        Dec_T --> Check_T
        End_All --> [*]
    }

```


# M7/W1/D1 - Tue, 1 July 25

Algorithm Principle

1. jarak, distance, difference, gap, two side of differnet pointer
2. incrementalism is the key of computer; you cannot shortuct; you cannot skip; you need to do incrementally; from the beginning, from the start; from the earliest; it start from the early; 
3. from creating component, you need to create subcompone;t you need to start from comment; 
4. the smallest things are the big things, is the early things are the sigficant team; in all things you need to go into detail and keep in your head; 
5. distance, frequency; differneces, index, sum total, value; minimum or maxinum; the minium amd maximum;; addition of the array; 
6. to get what we want value; max of what we want; the best of what we want; sometiems wits not right; or not the best; so we just ignore it; other than that;
7. before and after it; for every each of index; index come as the starting and end ; it never directly point tot he solution; but it need to rpocess for the currnely availabel stuff; 

# M6/W5/D26 - Thu, 26 June 25

Algorithm Principle

1. Find pattern of loop from n; 
2. creating the size n of array; and use it as saving point; 
3. creating matrix as the place; matrix; tos ave between i and j; as the comparison; and all the the possibility of options that exist; 
4. as always window expansion; from i to j; or wharteger it is as traditional mehtod of solving things; 
5. matrix and array size n; as the input and the output is count; 

# M6/W4/D24 -Wed, 24 June 25

Algorithm Principle

1. window expansion; from the 0 → to the n; region expation for the right; no expand for the left;
2. gap difference of things, → difference tells you a  lot of things about life
3. Rank order choice, rank order tells a lot about hgisn, why it should be put at first
4. counting things, count things help to understnad stuff;
5. key value pairs; do help the connection and the relationship of stuff; 
6. all you need is < = > and + / -;  expression vs statement
7. sub window, sub array 

# M6/W3/D23 - Mon 23 June 25

Algorithm Principle

1. region expansion, the first and the last, the is expanding, and the capture broad 
2. or independently processing; adding subtract and put and delete; 

# M6/W3/D20 -  Fri, 20 June 25

Algorithm Principle

1. window based; from the small to big; based on 0; 
2. process → max, min, get the prev; the the prev from future; update/adjust the number by add substract multiple divide; 

# M6/W3/D19 -  Thu, 19 June 25

Algorithm Principle

1. prefix sum is just window based sum, window algorithm → window max finding, window based process. 
2. window based proccess → window find max, find min. window prefix sum; window based; each window become their own point, where each point can be window again; 
3. the window you see right now, going to be recursive window you goignt ot use, after this; 

# M6/W2/D14 - Sat, 14 June 25

Algorithm Principle

1. understand the problem first, thats the first step of fundamental, that put you on the right path; other than that you will missed the path and just doing every step wrong. understand and recalibrate what you want.
2. order and two pointer → 

# M6/W2/D12 - Thu, 12 June 25

Algorithm Principle

1. to see from the problem based, or to see from the data structure based; 

# M6/W2/D11 - Wed, 11 June 25

Algorithm Principle

1. knowing if its sum, or count, or pick, or options trying, or what

# M5/W2/D19 -  Mon, 19 May 25

Algorithm Goals 

1. I want to undersand about greedy; i want to now deeper abot what isidie if else; 
2. i want to be intuitive about reading the problem;getting undrstand what is thes shape of it; getting understand what is the expecteted goals; getting understand what is the available operation; 
3. i want to understand deeply abuot greedy and the understandin of process and the transition relation to the next or the current; 
4. i want to have mind option of the what isndie the and what common thing to use in the inside if the and else;
5. i want to understand and rememebr the loop strategy and its variety of it; 

# M5/W2/D18  - Sun, 18 May 25

Algorithm Principle

1. FInd loop; knwoing the lop; but also it cominnew with the process and the judgement; 
2. looop canb be consider into several stuff;
    1. normal loops;
    2. loop fom the end; still normal;
    3. doubnle loops;
    4. from the end; from the i the firs tloop;
    5. from the end ; loop; 
3. loop as the logic process; that several process is more capable; than more; several process is impacting the loop itself;
